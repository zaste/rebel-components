<!DOCTYPE html>
<div data-cs="rebel-modal" 
     data-version="10.2.0"
     data-variant="default"
     data-state="idle"
     data-init="eager"
     data-capability="interactive">

<style>
/* üé≠ REBEL MODAL - MOST POPULAR COMPONENT */
/* Size: 6.8kb | Satisfaction: 92% | Usage: 21.8% | Capability: Interactive */

[data-cs="rebel-modal"] * { 
  margin: 0; 
  padding: 0; 
  box-sizing: border-box; 
}

[data-cs="rebel-modal"] {
  /* Local custom properties with system fallbacks */
  --_spacing: var(--rebel-spacing-3, 1.5rem);
  --_spacing-sm: var(--rebel-spacing-2, 1rem);
  --_spacing-lg: var(--rebel-spacing-4, 2rem);
  --_radius: var(--rebel-radius-lg, 0.75rem);
  --_shadow: var(--rebel-shadow-2xl, 0 25px 50px rgba(0,0,0,0.15));
  --_z-backdrop: var(--rebel-z-modal-backdrop, 400);
  --_z-modal: var(--rebel-z-modal, 500);
  --_duration: var(--rebel-duration-normal, 300ms);
  --_easing: var(--rebel-easing, cubic-bezier(0.4, 0, 0.2, 1));
  
  /* Component setup */
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  align-items: center;
  justify-content: center;
  padding: var(--_spacing);
  font-family: var(--rebel-font-family-sans, system-ui);
  z-index: var(--_z-modal);
}

/* State management */
[data-cs="rebel-modal"][data-state="open"] {
  display: flex;
}

[data-cs="rebel-modal"][data-state="opening"] {
  display: flex;
}

[data-cs="rebel-modal"][data-state="closing"] {
  display: flex;
}

/* Variants */
[data-cs="rebel-modal"][data-variant="compact"] {
  --_spacing: var(--rebel-spacing-2, 1rem);
  --_radius: var(--rebel-radius-md, 0.5rem);
}

[data-cs="rebel-modal"][data-variant="fullscreen"] {
  --_spacing: 0;
  --_radius: 0;
}

/* üå´Ô∏è BACKDROP */
.modal__backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--rebel-overlay, rgba(0, 0, 0, 0.5));
  backdrop-filter: blur(var(--rebel-backdrop-blur, 8px));
  -webkit-backdrop-filter: blur(var(--rebel-backdrop-blur, 8px));
  z-index: var(--_z-backdrop);
  
  /* Animation */
  opacity: 0;
  transition: opacity var(--_duration) var(--_easing);
}

[data-cs="rebel-modal"][data-state="open"] .modal__backdrop,
[data-cs="rebel-modal"][data-state="opening"] .modal__backdrop {
  opacity: 1;
}

[data-cs="rebel-modal"][data-state="closing"] .modal__backdrop {
  opacity: 0;
}

/* üì¶ MODAL CONTAINER */
.modal__container {
  position: relative;
  width: 100%;
  max-width: 32rem; /* 512px */
  max-height: calc(100vh - 2 * var(--_spacing));
  background: var(--rebel-surface, white);
  border-radius: var(--_radius);
  box-shadow: var(--_shadow);
  overflow: hidden;
  z-index: calc(var(--_z-modal) + 1);
  
  /* Animation */
  transform: scale(0.95) translateY(-1rem);
  opacity: 0;
  transition: all var(--_duration) var(--_easing);
}

[data-cs="rebel-modal"][data-state="open"] .modal__container {
  transform: scale(1) translateY(0);
  opacity: 1;
}

[data-cs="rebel-modal"][data-state="opening"] .modal__container {
  transform: scale(1) translateY(0);
  opacity: 1;
}

[data-cs="rebel-modal"][data-state="closing"] .modal__container {
  transform: scale(0.95) translateY(-1rem);
  opacity: 0;
}

/* Fullscreen variant */
[data-cs="rebel-modal"][data-variant="fullscreen"] .modal__container {
  max-width: 100%;
  max-height: 100%;
  width: 100%;
  height: 100%;
  border-radius: 0;
}

/* Compact variant */
[data-cs="rebel-modal"][data-variant="compact"] .modal__container {
  max-width: 24rem; /* 384px */
}

/* üìã MODAL HEADER */
.modal__header {
  position: relative;
  padding: var(--_spacing) var(--_spacing) var(--_spacing-sm);
  border-bottom: 1px solid var(--rebel-border, #dee2e6);
  background: var(--rebel-surface-alt, #f8f9fa);
}

.modal__title {
  font-size: var(--rebel-text-lg, 1.125rem);
  font-weight: var(--rebel-font-semibold, 600);
  color: var(--rebel-text, #212529);
  line-height: var(--rebel-leading-tight, 1.25);
  margin: 0;
  padding-right: 3rem; /* Space for close button */
}

.modal__close {
  position: absolute;
  top: var(--_spacing);
  right: var(--_spacing);
  width: 2.5rem;
  height: 2.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  border-radius: var(--rebel-radius-md, 0.5rem);
  background: transparent;
  color: var(--rebel-text-secondary, #6c757d);
  cursor: pointer;
  transition: var(--_duration);
  
  /* Accessibility */
  min-height: var(--rebel-touch-target, 44px);
  min-width: var(--rebel-touch-target, 44px);
}

.modal__close:hover {
  background: var(--rebel-hover, rgba(0, 123, 255, 0.1));
  color: var(--rebel-text, #212529);
}

.modal__close:focus-visible {
  outline: 2px solid var(--rebel-focus, #0066cc);
  outline-offset: 2px;
}

.modal__close-icon {
  width: 1.25rem;
  height: 1.25rem;
  stroke-width: 2;
}

/* üìÑ MODAL BODY */
.modal__body {
  padding: var(--_spacing);
  overflow-y: auto;
  max-height: calc(80vh - 8rem); /* Account for header and footer */
}

.modal__body:focus {
  outline: none;
}

/* Custom scrollbar for webkit browsers */
.modal__body::-webkit-scrollbar {
  width: 0.5rem;
}

.modal__body::-webkit-scrollbar-track {
  background: var(--rebel-surface-alt, #f8f9fa);
}

.modal__body::-webkit-scrollbar-thumb {
  background: var(--rebel-border-medium, #ced4da);
  border-radius: var(--rebel-radius-sm, 0.25rem);
}

.modal__body::-webkit-scrollbar-thumb:hover {
  background: var(--rebel-border-dark, #adb5bd);
}

/* üé¨ MODAL FOOTER */
.modal__footer {
  padding: var(--_spacing-sm) var(--_spacing) var(--_spacing);
  border-top: 1px solid var(--rebel-border, #dee2e6);
  background: var(--rebel-surface-alt, #f8f9fa);
  display: flex;
  gap: var(--_spacing-sm);
  justify-content: flex-end;
}

.modal__button {
  padding: calc(var(--_spacing-sm) * 0.75) var(--_spacing);
  border: 1px solid var(--rebel-border, #dee2e6);
  border-radius: var(--rebel-radius-md, 0.5rem);
  background: var(--rebel-surface, white);
  color: var(--rebel-text, #212529);
  font-size: var(--rebel-text-sm, 0.875rem);
  font-weight: var(--rebel-font-medium, 500);
  font-family: inherit;
  cursor: pointer;
  transition: var(--_duration);
  
  /* Accessibility */
  min-height: var(--rebel-touch-target, 44px);
  min-width: var(--rebel-touch-target, 44px);
}

.modal__button:hover:not(:disabled) {
  background: var(--rebel-hover, rgba(0, 123, 255, 0.1));
  border-color: var(--rebel-primary, #007bff);
}

.modal__button:focus-visible {
  outline: 2px solid var(--rebel-focus, #0066cc);
  outline-offset: 2px;
}

.modal__button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Primary button variant */
.modal__button--primary {
  background: var(--rebel-primary, #007bff);
  border-color: var(--rebel-primary, #007bff);
  color: var(--rebel-text-inverse, white);
}

.modal__button--primary:hover:not(:disabled) {
  background: var(--rebel-primary-hover, #0056b3);
  border-color: var(--rebel-primary-hover, #0056b3);
}

/* Danger button variant */
.modal__button--danger {
  background: var(--rebel-error, #dc3545);
  border-color: var(--rebel-error, #dc3545);
  color: var(--rebel-text-inverse, white);
}

.modal__button--danger:hover:not(:disabled) {
  background: var(--rebel-error-700, #c82333);
  border-color: var(--rebel-error-700, #c82333);
}

/* üì± RESPONSIVE DESIGN */
@media (max-width: 640px) {
  [data-cs="rebel-modal"] {
    padding: var(--_spacing-sm);
  }
  
  .modal__container {
    max-width: 100%;
    margin: 0;
  }
  
  .modal__header {
    padding: var(--_spacing-sm);
  }
  
  .modal__body {
    padding: var(--_spacing-sm);
    max-height: calc(100vh - 12rem);
  }
  
  .modal__footer {
    padding: var(--_spacing-sm);
    flex-direction: column-reverse;
  }
  
  .modal__button {
    width: 100%;
    justify-content: center;
  }
}

/* ‚ôø ACCESSIBILITY ENHANCEMENTS */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* High contrast mode */
@media (prefers-contrast: high) {
  [data-cs="rebel-modal"] {
    .modal__container {
      border: 2px solid;
    }
    
    .modal__close,
    .modal__button {
      border: 2px solid;
    }
  }
}

/* Dark mode adjustments */
@media (prefers-color-scheme: dark) {
  [data-cs="rebel-modal"] {
    .modal__backdrop {
      background: var(--rebel-overlay-heavy, rgba(0, 0, 0, 0.75));
    }
  }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  [data-cs="rebel-modal"] *,
  [data-cs="rebel-modal"] *::before,
  [data-cs="rebel-modal"] *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Print styles */
@media print {
  [data-cs="rebel-modal"] {
    position: static !important;
    display: block !important;
    width: auto !important;
    height: auto !important;
    padding: 0 !important;
  }
  
  .modal__backdrop {
    display: none !important;
  }
  
  .modal__container {
    max-width: none !important;
    max-height: none !important;
    transform: none !important;
    box-shadow: none !important;
    border: 1px solid #000 !important;
    page-break-inside: avoid;
  }
  
  .modal__close {
    display: none !important;
  }
}
</style>

<!-- üèóÔ∏è SEMANTIC HTML STRUCTURE -->
<div class="modal__backdrop" data-backdrop></div>

<div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-description">
  
  <!-- Header Section -->
  <header class="modal__header">
    <h2 class="modal__title" id="modal-title">
      <span data-text="title">Modal Title</span>
    </h2>
    
    <button 
      type="button" 
      class="modal__close" 
      data-close
      aria-label="Close modal"
    >
      <svg class="modal__close-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
  </header>
  
  <!-- Body Section -->
  <main class="modal__body" id="modal-description" tabindex="-1">
    <!-- Content slot -->
    <div data-slot="content">
      <p>Modal content goes here. Replace this with your own content.</p>
    </div>
  </main>
  
  <!-- Footer Section -->
  <footer class="modal__footer" data-slot="footer">
    <button type="button" class="modal__button" data-action="cancel">
      Cancel
    </button>
    <button type="button" class="modal__button modal__button--primary" data-action="confirm">
      Confirm
    </button>
  </footer>
  
  <!-- Screen reader announcements -->
  <div class="sr-only" role="status" aria-live="polite" aria-atomic="true" data-announcement></div>
  
</div>

<script>
(function() {
  'use strict';
  
  // üé≠ REBEL MODAL - MOST POPULAR COMPONENT
  class RebelModal extends (window.R?.Component || class {}) {
    constructor(element) {
      super?.(element);
      this.el = element;
      this.name = 'rebel-modal';
      this.version = '10.2.0';
      
      // Configuration
      this.config = {
        closeOnEscape: true,
        closeOnBackdrop: true,
        focusTrap: true,
        lockScroll: true,
        animation: true,
        autoFocus: true,
        returnFocus: true,
        persistent: false,
        ...this.parseConfig?.() || {}
      };
      
      // State management
      this.state = this.createState?.({
        isOpen: false,
        isAnimating: false,
        triggerElement: null
      }) || {
        isOpen: false,
        isAnimating: false,
        triggerElement: null
      };
      
      // Focus management
      this.focusableElements = [];
      this.previouslyFocused = null;
      this.scrollPosition = 0;
      
      this.init();
    }
    
    init() {
      try {
        // Cache elements
        this.cacheElements();
        
        // Setup accessibility
        this.setupAccessibility();
        
        // Bind events
        this.bindEvents();
        
        // Setup focus trap
        if (this.config.focusTrap) {
          this.setupFocusTrap();
        }
        
        // Mark as ready
        this.el.dataset.state = 'ready';
        this.emit?.('ready') || this.dispatchEvent('ready');
        
      } catch (error) {
        this.handleError(error);
      }
    }
    
    cacheElements() {
      this.elements = {
        backdrop: this.el.querySelector('[data-backdrop]'),
        container: this.el.querySelector('.modal__container'),
        title: this.el.querySelector('[data-text="title"]'),
        closeBtn: this.el.querySelector('[data-close]'),
        content: this.el.querySelector('[data-slot="content"]'),
        footer: this.el.querySelector('[data-slot="footer"]'),
        announcement: this.el.querySelector('[data-announcement]'),
        
        // Action buttons
        cancelBtn: this.el.querySelector('[data-action="cancel"]'),
        confirmBtn: this.el.querySelector('[data-action="confirm"]')
      };
      
      // Generate unique IDs
      const baseId = this.el.id || `modal-${Date.now()}`;
      this.elements.container.setAttribute('aria-labelledby', `${baseId}-title`);
      this.elements.container.setAttribute('aria-describedby', `${baseId}-description`);
      
      if (this.elements.title) {
        this.elements.title.id = `${baseId}-title`;
      }
      
      if (this.elements.content) {
        this.elements.content.id = `${baseId}-description`;
      }
    }
    
    setupAccessibility() {
      // Enhanced ARIA attributes
      this.el.setAttribute('role', 'presentation');
      this.elements.container.setAttribute('role', 'dialog');
      this.elements.container.setAttribute('aria-modal', 'true');
      
      // Hide from screen readers when closed
      this.el.setAttribute('aria-hidden', 'true');
      
      // Setup proper heading hierarchy
      if (this.elements.title && !this.elements.title.getAttribute('role')) {
        this.elements.title.setAttribute('role', 'heading');
        this.elements.title.setAttribute('aria-level', '1');
      }
    }
    
    setupFocusTrap() {
      this.updateFocusableElements();
    }
    
    updateFocusableElements() {
      const focusableSelectors = [
        'button:not([disabled])',
        '[href]:not([disabled])',
        'input:not([disabled]):not([type="hidden"])',
        'select:not([disabled])',
        'textarea:not([disabled])',
        '[tabindex]:not([tabindex="-1"]):not([disabled])',
        'details:not([disabled])',
        'summary:not(:disabled)'
      ].join(', ');
      
      this.focusableElements = Array.from(
        this.elements.container.querySelectorAll(focusableSelectors)
      );
    }
    
    bindEvents() {
      // Close button
      this.elements.closeBtn?.addEventListener('click', () => {
        this.close();
      });
      
      // Action buttons
      this.elements.cancelBtn?.addEventListener('click', () => {
        this.cancel();
      });
      
      this.elements.confirmBtn?.addEventListener('click', () => {
        this.confirm();
      });
      
      // Backdrop click
      if (this.config.closeOnBackdrop) {
        this.elements.backdrop?.addEventListener('click', () => {
          this.close();
        });
      }
      
      // Escape key
      if (this.config.closeOnEscape) {
        document.addEventListener('keydown', this.handleEscape.bind(this));
      }
      
      // Focus trap
      if (this.config.focusTrap) {
        this.elements.container.addEventListener('keydown', this.handleFocusTrap.bind(this));
      }
      
      // Animation end events
      this.elements.container.addEventListener('transitionend', this.handleTransitionEnd.bind(this));
    }
    
    // üé¨ CORE METHODS
    async open(triggerElement = null) {
      if (this.state.isOpen || this.state.isAnimating) return;
      
      // Store trigger element for focus return
      this.state.triggerElement = triggerElement || document.activeElement;
      
      // Emit opening event
      const openingEvent = this.emit?.('opening') || this.dispatchEvent('opening');
      if (openingEvent && openingEvent.defaultPrevented) return;
      
      // Set states
      this.state.isAnimating = true;
      this.el.dataset.state = 'opening';
      
      // Body scroll lock
      if (this.config.lockScroll) {
        this.lockBodyScroll();
      }
      
      // Show modal
      this.el.style.display = 'flex';
      this.el.setAttribute('aria-hidden', 'false');
      
      // Force reflow for animation
      if (this.config.animation) {
        this.elements.container.offsetHeight;
      }
      
      // Trigger animation
      requestAnimationFrame(() => {
        this.el.dataset.state = 'opening';
        
        // Complete after animation
        if (this.config.animation) {
          setTimeout(() => {
            this.completeOpen();
          }, this.getAnimationDuration());
        } else {
          this.completeOpen();
        }
      });
    }
    
    completeOpen() {
      this.state.isOpen = true;
      this.state.isAnimating = false;
      this.el.dataset.state = 'open';
      
      // Focus management
      if (this.config.autoFocus) {
        this.setInitialFocus();
      }
      
      // Update focusable elements
      if (this.config.focusTrap) {
        this.updateFocusableElements();
      }
      
      // Announce to screen readers
      this.announce('Modal opened');
      
      // Emit opened event
      this.emit?.('opened') || this.dispatchEvent('opened');
    }
    
    async close() {
      if (!this.state.isOpen || this.state.isAnimating) return;
      
      // Check if persistent
      if (this.config.persistent) {
        this.announce('Please complete the required actions before closing');
        return;
      }
      
      // Emit closing event
      const closingEvent = this.emit?.('closing') || this.dispatchEvent('closing');
      if (closingEvent && closingEvent.defaultPrevented) return;
      
      // Set states
      this.state.isAnimating = true;
      this.el.dataset.state = 'closing';
      
      // Trigger animation
      if (this.config.animation) {
        setTimeout(() => {
          this.completeClose();
        }, this.getAnimationDuration());
      } else {
        this.completeClose();
      }
    }
    
    completeClose() {
      this.state.isOpen = false;
      this.state.isAnimating = false;
      this.el.dataset.state = 'idle';
      
      // Hide modal
      this.el.style.display = 'none';
      this.el.setAttribute('aria-hidden', 'true');
      
      // Restore body scroll
      if (this.config.lockScroll) {
        this.unlockBodyScroll();
      }
      
      // Return focus
      if (this.config.returnFocus && this.state.triggerElement) {
        if (document.body.contains(this.state.triggerElement)) {
          this.state.triggerElement.focus();
        }
      }
      
      // Announce to screen readers
      this.announce('Modal closed');
      
      // Emit closed event
      this.emit?.('closed') || this.dispatchEvent('closed');
    }
    
    // üéØ ACTION METHODS
    cancel() {
      const cancelEvent = this.emit?.('cancel') || this.dispatchEvent('cancel');
      if (!cancelEvent || !cancelEvent.defaultPrevented) {
        this.close();
      }
    }
    
    confirm() {
      const confirmEvent = this.emit?.('confirm') || this.dispatchEvent('confirm');
      if (!confirmEvent || !cancelEvent.defaultPrevented) {
        this.close();
      }
    }
    
    // ‚å®Ô∏è KEYBOARD HANDLING
    handleEscape(e) {
      if (e.key === 'Escape' && this.state.isOpen) {
        e.preventDefault();
        this.close();
      }
    }
    
    handleFocusTrap(e) {
      if (e.key !== 'Tab' || !this.focusableElements.length) return;
      
      const firstFocusable = this.focusableElements[0];
      const lastFocusable = this.focusableElements[this.focusableElements.length - 1];
      
      if (e.shiftKey && document.activeElement === firstFocusable) {
        e.preventDefault();
        lastFocusable.focus();
      } else if (!e.shiftKey && document.activeElement === lastFocusable) {
        e.preventDefault();
        firstFocusable.focus();
      }
    }
    
    // üéØ FOCUS MANAGEMENT
    setInitialFocus() {
      // Priority order: autofocus element, first focusable, close button, container
      const autoFocus = this.elements.container.querySelector('[autofocus]');
      const firstFocusable = this.focusableElements[0];
      const focusTarget = autoFocus || firstFocusable || this.elements.closeBtn || this.elements.container;
      
      if (focusTarget) {
        focusTarget.focus();
      }
    }
    
    // üîí SCROLL LOCK
    lockBodyScroll() {
      this.scrollPosition = window.pageYOffset;
      this.originalStyles = {
        position: document.body.style.position,
        top: document.body.style.top,
        width: document.body.style.width,
        paddingRight: document.body.style.paddingRight,
        overflow: document.body.style.overflow
      };
      
      const scrollBarWidth = window.innerWidth - document.documentElement.clientWidth;
      
      Object.assign(document.body.style, {
        position: 'fixed',
        top: `-${this.scrollPosition}px`,
        width: '100%',
        paddingRight: `${scrollBarWidth}px`,
        overflow: 'hidden'
      });
    }
    
    unlockBodyScroll() {
      if (this.originalStyles) {
        Object.assign(document.body.style, this.originalStyles);
        window.scrollTo(0, this.scrollPosition);
      }
    }
    
    // üé® UI UPDATES
    setTitle(title) {
      if (this.elements.title) {
        this.elements.title.textContent = title;
      }
    }
    
    setContent(content) {
      if (this.elements.content) {
        if (typeof content === 'string') {
          this.elements.content.innerHTML = content;
        } else if (content instanceof Element) {
          this.elements.content.innerHTML = '';
          this.elements.content.appendChild(content);
        }
      }
      
      // Update focusable elements after content change
      if (this.config.focusTrap) {
        this.updateFocusableElements();
      }
    }
    
    // üõ†Ô∏è UTILITY METHODS
    getAnimationDuration() {
      const duration = getComputedStyle(this.elements.container).transitionDuration;
      return parseFloat(duration) * (duration.includes('ms') ? 1 : 1000);
    }
    
    handleTransitionEnd(e) {
      if (e.target === this.elements.container && e.propertyName === 'transform') {
        if (this.el.dataset.state === 'opening') {
          this.completeOpen();
        } else if (this.el.dataset.state === 'closing') {
          this.completeClose();
        }
      }
    }
    
    announce(message) {
      if (!this.elements.announcement) return;
      
      this.elements.announcement.textContent = message;
      
      // Clear after delay
      setTimeout(() => {
        this.elements.announcement.textContent = '';
      }, 1000);
    }
    
    // üö® ERROR HANDLING
    handleError(error) {
      console.error('[RebelModal] Error:', error);
      this.el.dataset.state = 'error';
      this.emit?.('error', { error }) || this.dispatchEvent('error', { error });
    }
    
    // üé≠ EVENT SYSTEM
    emit(eventName, detail = {}) {
      if (super.emit) {
        return super.emit(eventName, detail);
      }
      return this.dispatchEvent(eventName, detail);
    }
    
    dispatchEvent(eventName, detail = {}) {
      const event = new CustomEvent(`rebel:modal:${eventName}`, {
        detail: { instance: this, ...detail },
        bubbles: true,
        cancelable: true
      });
      
      this.el.dispatchEvent(event);
      return event;
    }
    
    on(eventName, handler) {
      this.el.addEventListener(`rebel:modal:${eventName}`, handler);
      return () => this.off(eventName, handler);
    }
    
    off(eventName, handler) {
      this.el.removeEventListener(`rebel:modal:${eventName}`, handler);
    }
    
    // üßπ CLEANUP
    destroy() {
      // Close if open
      if (this.state.isOpen) {
        this.completeClose();
      }
      
      // Remove global listeners
      document.removeEventListener('keydown', this.handleEscape);
      
      // Call parent destroy
      if (super.destroy) {
        super.destroy();
      }
      
      this.dispatchEvent('destroyed');
    }
    
    // üîç PUBLIC API
    toggle(triggerElement = null) {
      if (this.state.isOpen) {
        this.close();
      } else {
        this.open(triggerElement);
      }
    }
    
    isOpen() {
      return this.state.isOpen;
    }
    
    setPersistent(persistent) {
      this.config.persistent = persistent;
    }
  }
  
  // üöÄ AUTO-INITIALIZATION
  function initRebelModals() {
    const modals = document.querySelectorAll('[data-cs="rebel-modal"]:not([data-init="true"])');
    
    modals.forEach(element => {
      try {
        new RebelModal(element);
      } catch (error) {
        console.error('Failed to initialize RebelModal:', error);
        element.dataset.state = 'error';
      }
    });
  }
  
  // Register with Rebel system if available
  if (window.R?.register) {
    window.R.register('rebel-modal', RebelModal);
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initRebelModals);
  } else {
    initRebelModals();
  }
  
  // Webflow integration
  if (window.Webflow) {
    window.Webflow.push(initRebelModals);
  }
  
  // Mutation observer for dynamic content
  if (window.MutationObserver) {
    const observer = new MutationObserver((mutations) => {
      let hasNewModals = false;
      
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === 1) {
            if (node.matches?.('[data-cs="rebel-modal"]:not([data-init="true"])')) {
              hasNewModals = true;
            } else if (node.querySelector?.('[data-cs="rebel-modal"]:not([data-init="true"])')) {
              hasNewModals = true;
            }
          }
        });
      });
      
      if (hasNewModals) {
        setTimeout(initRebelModals, 10);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
})();
</script>

</div>
