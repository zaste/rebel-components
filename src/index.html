<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RUN:REBEL Terminal Hero - Live Preview</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../design-system.css">
</head>
<body style="margin: 0; padding: 2rem; background: #000; font-family: 'JetBrains Mono', monospace;">

<!-- 
üéØ GTM INTEGRATION NOTES:
- GTM scripts should be installed globally in Webflow Project Settings
- This component sends events to the global dataLayer
- No additional GTM installation needed
-->

<div data-cs="terminal-hero" 
     data-phrases='["REAL MISSION", "REAL STAKES", "REAL REWARDS"]'
     data-speed="50"
     data-pause-on-dot="600"
     data-cta="RUN: REBEL"
     data-use-real-coords="true"
     data-debug-mode="true">

<style>
:root {
    --primary: #FF3131;
    --white: #FFF;
    --black: #000;
    --primary-20: rgba(255, 49, 49, 0.1);
    --primary-60: rgba(255, 49, 49, 0.6);
    --transition: all 0.3s ease;
}

[data-cs="terminal-hero"] {
    position: relative;
    width: 100%;
    height: auto;
    font-family: 'JetBrains Mono', monospace;
    color: var(--white);
    box-sizing: border-box;
}

.hero-terminal {
    position: relative;
    padding: clamp(1rem, 4vw, 3rem);
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(2px);
    border: 2px solid var(--primary);
    border-radius: 4px;
    box-shadow: inset 0 0 20px #FF313120, 0 0 40px #00000080;
    cursor: pointer;
    transition: var(--transition);
    min-height: clamp(250px, 40vh, 400px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
}

.hero-terminal:hover {
    border-color: var(--primary);
    box-shadow: inset 0 0 30px #FF313130, 0 0 60px var(--primary);
}

.hero-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 0.3rem 1rem;
    background: var(--primary-20);
    color: var(--primary);
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 2px;
    border-bottom: 1px solid var(--primary-60);
    text-transform: uppercase;
    text-align: left;
    box-sizing: border-box;
}

.hero-display {
    width: 100%;
    margin: clamp(1.5rem, 4vw, 2.5rem) 0 clamp(0.5rem, 2vw, 1rem) 0;
    min-height: clamp(100px, 20vh, 140px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    gap: clamp(0.5rem, 1.5vw, 0.875rem);
    padding: 0 clamp(0.5rem, 2vw, 1rem);
    box-sizing: border-box;
}

.hero-line {
    font-size: clamp(1.25rem, 6vw, 4rem);
    font-weight: 800;
    line-height: 1.1;
    color: #FFFFFF;
    text-shadow: 0 0 5px #FFFFFF40;
    text-transform: uppercase;
    margin: 0;
    opacity: 0;
    transform: translateY(10px);
    transition: var(--transition);
    text-align: center;
    letter-spacing: clamp(-0.02em, -0.01vw, -0.02em);
    word-break: break-word;
    hyphens: auto;
    max-width: 100%;
    box-sizing: border-box;
}

.hero-line.active {
    opacity: 1;
    transform: translateY(0);
}

.hero-cursor-line {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: clamp(1.25rem, 3vw, 2rem);
    width: 100%;
}

.hero-cursor {
    display: inline-block;
    width: clamp(10px, 1.5vw, 16px);
    height: clamp(1em, 1.2em, 1.4em);
    background: var(--primary);
    box-shadow: 0 0 15px var(--primary);
    animation: blink 1.2s step-end infinite;
    opacity: 0;
    transform: translateY(10px);
    transition: var(--transition);
    border-radius: 1px;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    50.01%, 100% { opacity: 0; }
}

.hero-skip {
    position: absolute;
    top: clamp(1rem, 3vw, 2rem);
    right: clamp(0.5rem, 2vw, 1.5rem);
    padding: clamp(0.375rem, 1vw, 0.5rem) clamp(0.5rem, 1.5vw, 0.75rem);
    background: #000000CC;
    border: 1px solid var(--primary-60);
    color: #6c757d;
    font-family: inherit;
    font-size: clamp(0.6rem, 1.2vw, 0.75rem);
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: clamp(0.5px, 0.1vw, 1px);
    border-radius: 2px;
    cursor: pointer;
    opacity: 0;
    transform: translateY(-10px);
    transition: var(--transition);
    z-index: 200;
    white-space: nowrap;
    box-sizing: border-box;
}

.hero-skip.visible {
    opacity: 1;
    transform: translateY(0);
}

.hero-skip:hover {
    color: var(--primary);
    border-color: var(--primary);
    box-shadow: 0 0 20px var(--primary);
}

.hero-cta {
    margin-top: clamp(0.5rem, 1.5vw, 1rem);
    padding: clamp(0.75rem, 2vw, 1rem) clamp(1.5rem, 4vw, 2rem);
    background: #000000E6;
    border: 2px solid var(--primary);
    color: var(--white);
    font-family: inherit;
    font-weight: 700;
    font-size: clamp(1rem, 2.5vw, 1.25rem);
    text-transform: uppercase;
    letter-spacing: clamp(0.5px, 0.1vw, 1px);
    border-radius: 4px;
    cursor: pointer;
    transition: var(--transition);
    opacity: 0;
    transform: translateY(20px);
    box-shadow: 0 0 20px var(--primary);
    min-height: clamp(40px, 8vw, 50px);
    width: 100%;
    max-width: clamp(200px, 50vw, 300px);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
}

.hero-cta.visible {
    opacity: 1;
    transform: translateY(0);
}

.hero-cta::before {
    content: '>> ';
    margin-right: 0.5rem;
    color: var(--primary);
    font-weight: 800;
    font-size: 1.1em;
    text-shadow: 0 0 8px var(--primary);
}

.hero-cta:hover {
    background: var(--primary);
    color: var(--black);
    transform: translateY(-2px);
}

.hero-cta:hover::before {
    color: var(--black);
}

.hero-footer {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: clamp(0.375rem, 1vw, 0.5rem) clamp(0.75rem, 2vw, 1.5rem);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: clamp(0.55rem, 1vw, 0.65rem);
    color: #FFFFFF99;
    font-weight: 400;
    pointer-events: none;
    box-sizing: border-box;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.hero-status {
    display: flex;
    align-items: center;
    gap: 0.3rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--primary);
}

.hero-status::before {
    content: '‚óè';
    color: var(--primary);
    font-size: 0.5rem;
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
}

@media (max-width: 479px) {
    .hero-terminal { min-height: clamp(200px, 50vh, 300px); }
    .hero-line { font-size: clamp(1rem, 8vw, 1.5rem); line-height: 1.2; }
    .hero-cta { font-size: 0.9rem; padding: 0.75rem 1rem; margin-top: 0.5rem; }
}

@media (prefers-reduced-motion: reduce) {
    .hero-cursor { animation: none; opacity: 1; }
    .hero-line, .hero-cta, .hero-skip { transition-duration: 0.01ms; }
}
</style>

<div class="hero-terminal" data-clickable="restart">
    <div class="hero-header">
        <span>RUN:REBEL > SYSTEM READY</span>
    </div>
    
    <button class="hero-skip" data-skip>[ESC] SKIP</button>
    
    <div class="hero-display" data-display>
        <div class="hero-line" data-text></div>
        <div class="hero-cursor-line">
            <span class="hero-cursor" data-cursor></span>
        </div>
    </div>
    
    <button class="hero-cta" data-cta>
        <span>RUN: REBEL</span>
    </button>
    
    <div class="hero-footer">
        <div data-coords>LAT: 42.8584¬∞ N | LON: 2.6456¬∞ W</div>
        <div class="hero-status">LIVE</div>
    </div>
</div>

</div>

<script>
// üöÄ ULTRA-SIMPLIFIED VERSION WITH GTM INTEGRATION
// Reduced from 1000+ lines to ~200 lines!

(function() {
    'use strict';
    
    // Initialize dataLayer for GTM
    window.dataLayer = window.dataLayer || [];
    
    class TerminalHero {
        constructor(element) {
            this.el = element;
            this.config = this.parseConfig();
            this.state = { isTyping: false, isComplete: false };
            this.timers = new Set();
            this.userData = this.collectUserData(); // Collect once on init
            this.init();
        }
        
        parseConfig() {
            const { dataset } = this.el;
            return {
                phrases: JSON.parse(dataset.phrases || '["READY"]'),
                speed: parseInt(dataset.speed) || 50,
                cta: dataset.cta || 'START',
                useRealCoords: dataset.useRealCoords === 'true',
                pauseOnDot: parseInt(dataset.pauseOnDot) || 400,
                debugMode: dataset.debugMode === 'true'
            };
        }
        
        collectUserData() {
            // üéØ MINIMALIST DATA COLLECTION - Only unique/essential data
            return {
                // ESENCIAL - IDs √∫nicos
                anonymous_id: this.getOrCreateAnonymousId(),
                session_id: crypto.randomUUID ? crypto.randomUUID() : this.generateFallbackUUID(),
                
                // ESENCIAL - Engagement espec√≠fico del terminal
                visit_count: this.getVisitCount(),
                
                // ESENCIAL - Hardware cr√≠tico para segmentaci√≥n
                device_type: window.innerWidth < 768 ? 'mobile' : window.innerWidth < 1024 ? 'tablet' : 'desktop',
                
                // √öNICO - Datos que GTM no puede obtener f√°cilmente
                cpu_cores: navigator.hardwareConcurrency || 0,
                memory_gb: navigator.deviceMemory || 0,
            };
        }
        
        getOrCreateAnonymousId() {
            const storageKey = 'rr_anonymous_id';
            let anonymousId;
            
            try {
                anonymousId = localStorage.getItem(storageKey);
            } catch (e) {
                try {
                    anonymousId = sessionStorage.getItem(storageKey);
                } catch (e2) {
                    anonymousId = null;
                }
            }
            
            if (!anonymousId) {
                anonymousId = crypto.randomUUID ? 
                    crypto.randomUUID() : 
                    this.generateFallbackUUID();
                
                try {
                    localStorage.setItem(storageKey, anonymousId);
                } catch (e) {
                    try {
                        sessionStorage.setItem(storageKey, anonymousId);
                    } catch (e2) {}
                }
            }
            
            return anonymousId;
        }
        
        generateFallbackUUID() {
            return 'xxxx-xxxx-4xxx-yxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        init() {
            this.bindEvents();
            if (this.config.useRealCoords) this.getRealCoordinates();
            
            // üìä GTM EVENT: Terminal Load
            this.sendGTMEvent('terminal_load', {
                ...this.userData,
                terminal_version: '2.0_gtm'
            });
            
            this.start();
        }
        
        bindEvents() {
            const skip = this.el.querySelector('[data-skip]');
            const terminal = this.el.querySelector('[data-clickable]');
            const cta = this.el.querySelector('[data-cta]');
            
            skip?.addEventListener('click', () => this.skip());
            terminal?.addEventListener('click', () => this.restart());
            cta?.addEventListener('click', () => this.executeCTA());
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.state.isTyping) this.skip();
            });
        }
        
        sendGTMEvent(eventName, data = {}) {
            const eventData = {
                event: eventName,
                ...data,
                event_timestamp: Date.now()
            };
            
            if (this.config.debugMode) {
                console.log('üìä GTM Event:', eventName, eventData);
            }
            
            dataLayer.push(eventData);
        }
        
        async start() {
            if (this.state.isTyping) return;
            
            this.state.isTyping = true;
            const startTime = performance.now();
            const textEl = this.el.querySelector('[data-text]');
            const cursorEl = this.el.querySelector('[data-cursor]');
            const skipBtn = this.el.querySelector('[data-skip]');
            
            textEl.classList.add('active');
            skipBtn?.classList.add('visible');
            
            setTimeout(() => {
                cursorEl.style.opacity = '1';
                cursorEl.style.transform = 'translateY(0)';
            }, 300);
            
            // üìä GTM EVENT: Typing Start
            this.sendGTMEvent('terminal_typing_start', {
                ...this.userData,
                phrases_count: this.config.phrases.length,
                typing_speed: this.config.speed
            });
            
            try {
                const fullText = this.config.phrases.join('. ') + '.';
                
                for (let i = 0; i <= fullText.length && this.state.isTyping; i++) {
                    textEl.textContent = fullText.substring(0, i);
                    await this.wait(this.config.speed);
                    
                    if (fullText[i - 1] === '.' && i < fullText.length) {
                        await this.wait(this.config.pauseOnDot);
                    }
                }
                
                if (this.state.isTyping) {
                    const endTime = performance.now();
                    
                    // üìä GTM EVENT: Typing Complete
                    this.sendGTMEvent('terminal_typing_complete', {
                        ...this.userData,
                        typing_duration: Math.round(endTime - startTime),
                        text_length: fullText.length,
                        was_skipped: false
                    });
                    
                    this.complete();
                }
            } catch (error) {
                this.handleError();
            }
        }
        
        complete() {
            this.state.isTyping = false;
            this.state.isComplete = true;
            
            this.el.querySelector('[data-skip]')?.classList.remove('visible');
            
            setTimeout(() => {
                this.el.querySelector('[data-cta]')?.classList.add('visible');
                
                // üìä GTM EVENT: CTA Shown
                this.sendGTMEvent('terminal_cta_shown', {
                    ...this.userData,
                    cta_text: this.config.cta
                });
            }, 500);
        }
        
        skip() {
            if (!this.state.isTyping) return;
            
            this.state.isTyping = false;
            const textEl = this.el.querySelector('[data-text]');
            const cursorEl = this.el.querySelector('[data-cursor]');
            
            textEl.textContent = this.config.phrases.join('. ') + '.';
            cursorEl.style.opacity = '1';
            cursorEl.style.transform = 'translateY(0)';
            
            // üìä GTM EVENT: Typing Skipped
            this.sendGTMEvent('terminal_typing_skipped', {
                ...this.userData,
                skip_method: 'button_click'
            });
            
            this.complete();
        }
        
        restart() {
            // üìä GTM EVENT: Terminal Restart
            this.sendGTMEvent('terminal_restart', {
                ...this.userData,
                restart_source: 'terminal_click'
            });
            
            this.state.isComplete = false;
            
            const textEl = this.el.querySelector('[data-text]');
            const cursorEl = this.el.querySelector('[data-cursor]');
            const cta = this.el.querySelector('[data-cta]');
            
            textEl.textContent = '';
            textEl.classList.remove('active');
            textEl.style.color = '';
            cta?.classList.remove('visible');
            
            cursorEl.style.opacity = '0';
            cursorEl.style.transform = 'translateY(10px)';
            
            setTimeout(() => this.start(), 100);
        }
        
        async executeCTA() {
            const cta = this.el.querySelector('[data-cta] span');
            
            if (cta?.parentElement.dataset.loading === 'true') return;
            
            if (this.state.hasError) {
                this.restart();
                return;
            }
            
            const clickTime = performance.now();
            
            // üìä GTM EVENT: CTA Click (MAIN EVENT) - Con PK optimizada
            this.sendGTMEvent('terminal_cta_click', {
                // PRIMARY KEY COMPUESTA
                interaction_id: this.userData.anonymous_id + '_' + this.userData.session_id + '_' + Date.now(),
                
                // DATOS √öNICOS DEL COMPONENTE
                anonymous_id: this.userData.anonymous_id,
                session_id: this.userData.session_id,
                device_type: this.userData.device_type,
                visit_count: this.userData.visit_count,
                cpu_cores: this.userData.cpu_cores,
                memory_gb: this.userData.memory_gb,
                
                // DATOS ESPEC√çFICOS DEL EVENTO
                coordinates: this.getCurrentCoordinates(),
                time_to_click: Math.round(clickTime),
                engagement_score: this.calculateEngagementScore(),
            });
            
            cta.parentElement.dataset.loading = 'true';
            
            const steps = ['AUTHENTICATING', 'PROCESSING', 'PROTOCOL ACTIVE'];
                
            for (const step of steps) {
                cta.textContent = `${step}...`;
                await this.wait(500);
            }
            
            cta.parentElement.dataset.loading = 'false';
            cta.textContent = 'AUTHENTICATED';
            
            setTimeout(() => {
                cta.textContent = this.config.cta;
            }, 2000);
        }
        
        getCurrentCoordinates() {
            const coords = this.el.querySelector('[data-coords]');
            const coordsText = coords?.textContent || '';
            const coordsMatch = coordsText.match(/LAT: ([\d.-]+)¬∞ ([NS]) \| LON: ([\d.-]+)¬∞ ([EW])/);
            
            if (coordsMatch) {
                const [, lat, latDir, lon, lonDir] = coordsMatch;
                return {
                    latitude: (latDir === 'S' ? -1 : 1) * parseFloat(lat),
                    longitude: (lonDir === 'W' ? -1 : 1) * parseFloat(lon)
                };
            }
            return null;
        }
        
        calculateEngagementScore() {
            let score = 0;
            score += Math.min(performance.now() / 10000, 10); // Time on page (max 10)
            score += this.state.isComplete ? 5 : 0; // Completed typing
            return Math.round(score);
        }
        
        getVisitCount() {
            try {
                const count = parseInt(localStorage.getItem('rr_visit_count') || '0') + 1;
                localStorage.setItem('rr_visit_count', count.toString());
                return count;
            } catch (e) {
                return 1;
            }
        }
        
        async getRealCoordinates() {
            const coords = this.el.querySelector('[data-coords]');
            const status = this.el.querySelector('.hero-status');
            
            if (!coords) return;
            
            coords.textContent = 'LAT: LOCATING... | LON: LOCATING...';
            if (status) status.textContent = 'SCANNING';
            
            try {
                const response = await fetch('https://ipapi.co/json/');
                const data = await response.json();
                
                if (data.latitude && data.longitude) {
                    const lat = parseFloat(data.latitude);
                    const lon = parseFloat(data.longitude);
                    const latDir = lat >= 0 ? 'N' : 'S';
                    const lonDir = lon >= 0 ? 'E' : 'W';
                    
                    coords.textContent = 
                        `LAT: ${Math.abs(lat).toFixed(4)}¬∞ ${latDir} | LON: ${Math.abs(lon).toFixed(4)}¬∞ ${lonDir}`;
                    if (status) status.textContent = 'LIVE';
                    
                    // üìä GTM EVENT: Coordinates Located
                    this.sendGTMEvent('coordinates_located', {
                        ...this.userData,
                        latitude: lat,
                        longitude: lon,
                        location_method: 'ip_geolocation'
                    });
                }
            } catch (error) {
                coords.textContent = 'LAT: 42.8584¬∞ N | LON: 2.6456¬∞ W';
                if (status) status.textContent = 'OFFLINE';
                
                // üìä GTM EVENT: Coordinates Failed
                this.sendGTMEvent('coordinates_failed', {
                    ...this.userData,
                    error_message: error.message
                });
            }
        }
        
        handleError() {
            const textEl = this.el.querySelector('[data-text]');
            const cursorEl = this.el.querySelector('[data-cursor]');
            
            textEl.textContent = 'ERROR: SYSTEM MALFUNCTION';
            textEl.style.color = '#dc3545';
            
            cursorEl.style.opacity = '1';
            cursorEl.style.transform = 'translateY(0)';
            
            // üìä GTM EVENT: Terminal Error
            this.sendGTMEvent('terminal_error', {
                ...this.userData,
                error_type: 'typing_failure'
            });
            
            this.complete();
        }
        
        wait(ms) {
            return new Promise(resolve => {
                const timer = setTimeout(() => {
                    this.timers.delete(timer);
                    resolve();
                }, ms);
                this.timers.add(timer);
            });
        }
        
        destroy() {
            this.timers.forEach(clearTimeout);
            this.timers.clear();
            delete this.el._heroInstance;
        }
    }
    
    function init() {
        document.querySelectorAll('[data-cs="terminal-hero"]:not([data-init])').forEach(el => {
            el._heroInstance = new TerminalHero(el);
            el.dataset.init = 'true';
        });
    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    
    window.TerminalHero = TerminalHero;
    
    // üß™ Debug helper
    if (document.querySelector('[data-debug-mode="true"]')) {
        console.log('üî¨ RUN:REBEL GTM Debug Mode Active');
        console.log('üìä DataLayer events will be logged to console');
        
        window.RR_DEBUG = {
            getDataLayer: () => window.dataLayer,
            getAnonymousId: () => {
                const instance = document.querySelector('[data-cs="terminal-hero"]')?._heroInstance;
                return instance?.userData.anonymous_id;
            },
            testEvent: (eventName, data) => {
                window.dataLayer.push({
                    event: eventName,
                    ...data,
                    test: true
                });
                console.log('üìä Test event sent:', eventName, data);
            }
        };
        
        console.log('üõ†Ô∏è Debug helpers available: window.RR_DEBUG');
    }
})();
</script>

</body>
</html>